DR. MARIO CLONE - PROJECT DOCUMENTATION
==========================================

This is a comprehensive Dr. Mario clone built with vanilla JavaScript, featuring both single-player and multiplayer modes. The game uses Web Components and Socket.IO for real-time multiplayer functionality.

OVERALL ARCHITECTURE:
====================
The game is built using a modular architecture with separate files for different game components. There are two parallel sets of files - one for Player 1 and one for Player 2, allowing for side-by-side multiplayer gameplay.

CORE GAME FILES:
================

1. GAME.JS / GAME2.JS
   Purpose: Main game controller and orchestrator
   Key Features:
   - Extends HTMLElement to create a custom web component
   - Manages the overall game state and lifecycle
   - Handles game initialization, level progression, and game over states
   - Integrates with Socket.IO for multiplayer functionality
   - Manages the dancing virus animations around the game board
   - Controls background changes based on level progression
   - Handles victory/defeat scenarios in multiplayer mode

   Vital Functions:
   - createBoard(): Initializes the game board
   - nextStage(): Handles level completion and progression
   - endGame(): Manages game over state and restart
   - setupSocketListeners(): Handles multiplayer communication
   - showWinScreen()/showOpponentWinScreen(): Multiplayer victory/defeat displays

2. BOARD.JS / BOARD2.JS
   Purpose: Core game logic and board management
   Key Features:
   - Manages the 8x17 game grid where pills and viruses are placed
   - Handles pill movement, rotation, and placement
   - Implements virus spawning and management
   - Manages score tracking and display
   - Handles line clearing mechanics (3+ in a row/column)
   - Implements gravity system for falling pieces
   - Manages the throwing board animation sequence
   - Handles multiplayer damage system (sending viruses to opponent)

   Vital Functions:
   - nextFrame(): Main game loop that handles pill falling and virus spawning
   - spawnViruses(): Places viruses on the board at game start
   - clearIfNeeded(): Checks for and clears matching lines
   - useGravitation(): Makes pieces fall after line clears
   - hurt(): Spawns random colored dots that fall and become viruses (multiplayer damage)
   - spawnRandomDot(): Creates falling damage pieces

3. SHAPE.JS / SHAPE2.JS
   Purpose: Defines game pieces (pills and viruses)
   Key Features:
   - Pill class: Two-colored capsules that can be rotated and moved
   - Virus class: Single-colored targets that must be eliminated
   - ShapePiece class: Individual components of shapes
   - Handles movement validation and collision detection
   - Manages rotation mechanics with wall collision prevention
   - Implements the random color generation system for pills

   Vital Functions:
   - move(): Handles piece movement with boundary checking
   - rotate(): Manages pill rotation with collision detection
   - place(): Locks pieces in place when they land
   - canMove()/canRotate(): Validation functions for movement

4. COMPONENTS.JS / COMPONENTS2.JS
   Purpose: Constants and configuration
   Key Features:
   - Color definitions (bl=blue, br=brown, yl=yellow)
   - Direction vectors for movement
   - Rotation states for pills
   - Timing constants for animations and game speed

   Vital Data:
   - Color enum: Maps game colors to image file prefixes
   - Direction enum: X/Y coordinate changes for movement
   - DELAY object: Timing constants for smooth gameplay

5. SCRIPT.JS / SCRIPT2.JS
   Purpose: Game initialization and entry points
   Key Features:
   - Creates game instances for each player
   - Attaches games to DOM containers
   - Simple initialization scripts

   Function:
   - Instantiates Game class and appends to designated containers
   - Enables side-by-side multiplayer gameplay


MULTIPLAYER SYSTEM:
==================
The game uses Socket.IO for real-time multiplayer communication:

- Room-based multiplayer with unique room codes
- Synchronized virus positions between players
- Damage system: clearing lines sends viruses to opponent
- Point tracking and transmission
- Victory/defeat detection and communication
- Real-time game state synchronization

GAME MECHANICS:
===============
1. Pill Mechanics:
   - Two-colored capsules that fall from the top
   - Can be rotated in 4 directions (horizontal, vertical, etc.)
   - Must match 3+ same colors in a row/column to clear
   - Clearing lines eliminates viruses of matching colors

2. Virus System:
   - Single-colored targets that must be eliminated
   - Spawned at game start in random positions
   - Can be cleared by matching their color with pills
   - Dancing animation around the board perimeter

3. Scoring System:
   - Points awarded for clearing viruses
   - Bonus points for line clears
   - High score tracking with localStorage

4. Multiplayer Damage:
   - Clearing lines sends falling colored dots to opponent
   - Dots fall and become viruses when they land
   - Creates competitive pressure between players

TECHNICAL IMPLEMENTATION:
=========================
- Uses ES6 modules for code organization
- Web Components for custom HTML elements
- Canvas-free rendering using CSS positioning
- Socket.IO for real-time communication
- Local storage for high score persistence
- Responsive design with fixed pixel dimensions

FILE DEPENDENCIES:
==================
- Game.js imports Board.js and components.js
- Board.js imports Shape.js and components.js
- Shape.js imports components.js
- Script.js imports Game.js
- All files use Socket.IO for multiplayer features

This architecture allows for clean separation of concerns while maintaining the classic Dr. Mario gameplay experience with modern web technologies and multiplayer capabilities.

CONSOLIDATION ANALYSIS & STRATEGIES:
====================================

After analyzing the parallel file structure, here are the key differences and consolidation strategies:

KEY DIFFERENCES BETWEEN PARALLEL FILES:
=======================================

1. GAME.JS vs GAME2.JS:
   - Player Number: Game.js uses playerNumber: 1, Game2.js uses playerNumber: 2
   - Socket Listeners: Game.js listens for playerNumber === 2, Game2.js listens for playerNumber === 1
   - Import Paths: Game.js imports from "./Board.js", Game2.js imports from "./Board2.js"
   - Import Paths: Game.js imports from "./components.js", Game2.js imports from "./components2.js"

2. BOARD.JS vs BOARD2.JS:
   - Player Variable: Board.js has `var player = 1`, Board2.js has `var player = 2`
   - Initial undery Values: Board.js starts with `undery = 14`, Board2.js starts with `undery = 6`
   - Socket Events: Board.js listens for 'p1damage', Board2.js listens for 'p2damage'
   - Point Updates: Board.js emits 'updatePoints2', Board2.js emits 'updatePoints1'
   - Import Paths: Board.js imports from "./Shape.js", Board2.js imports from "./Shape2.js"
   - Import Paths: Board.js imports from "./components.js", Board2.js imports from "./components2.js"

3. SHAPE.JS vs SHAPE2.JS:
   - Import Paths: Shape.js imports from "./Board.js", Shape2.js imports from "./Board2.js"
   - Import Paths: Shape.js imports from "./components.js", Shape2.js imports from "./components2.js"
   - Functionality: Identical except for import paths

4. COMPONENTS.JS vs COMPONENTS2.JS:
   - Content: Completely identical files
   - No functional differences

5. SCRIPT.JS vs SCRIPT2.JS:
   - Import Paths: Script.js imports from "./Game.js", Script2.js imports from "./Game2.js"
   - DOM Containers: Script.js appends to "game1", Script2.js appends to "game2"
   - Functionality: Identical except for import paths and container IDs

CONSOLIDATION STRATEGIES:
========================

1. UNIFIED GAME.JS:
   - Add constructor parameter: `constructor(playerNumber = 1)`
   - Store player number: `this.playerNumber = playerNumber`
   - Dynamic imports: Use conditional imports or pass playerNumber to Board
   - Socket listeners: Use `this.playerNumber` instead of hardcoded values
   - Example: `if (data.playerNumber === (this.playerNumber === 1 ? 2 : 1))`

2. UNIFIED BOARD.JS:
   - Add constructor parameter: `constructor(game, level = 0, score = 0, playerNumber = 1)`
   - Store player number: `this.playerNumber = playerNumber`
   - Dynamic undery initialization: `this.undery = playerNumber === 1 ? 14 : 6`
   - Dynamic socket events: Use template literals for event names
   - Example: `socket.on('p${playerNumber}damage', ...)`
   - Dynamic point updates: `socket.emit('updatePoints${playerNumber === 1 ? 2 : 1}', ...)`

3. UNIFIED SHAPE.JS:
   - Remove import path dependencies by passing board reference
   - Use dynamic imports or make components.js import path-agnostic
   - No player-specific logic needed in Shape classes

4. UNIFIED COMPONENTS.JS:
   - Keep as single file (components2.js can be deleted)
   - No changes needed - already identical

5. UNIFIED SCRIPT.JS:
   - Create two game instances with different player numbers
   - Example: `new Game(1)` and `new Game(2)`
   - Pass player number to constructor

IMPLEMENTATION APPROACH:
========================

1. PHASE 1 - Create Unified Files:
   - Create new unified Game.js with playerNumber parameter
   - Create new unified Board.js with playerNumber parameter
   - Create new unified Shape.js with dynamic imports
   - Keep single components.js
   - Update script.js to create two instances

2. PHASE 2 - Dynamic Player Handling:
   - Replace all hardcoded player numbers with `this.playerNumber`
   - Replace all hardcoded socket event names with dynamic strings
   - Replace all hardcoded undery values with conditional logic
   - Update all import statements to use unified files

3. PHASE 3 - Testing & Validation:
   - Test single player mode (playerNumber = 1)
   - Test multiplayer mode with both players
   - Verify socket communication works correctly
   - Verify damage system works bidirectionally

4. PHASE 4 - Cleanup:
   - Delete old parallel files (Game2.js, Board2.js, Shape2.js, components2.js, script2.js)
   - Update any remaining references
   - Test final consolidated version

CRITICAL CONSIDERATIONS:
========================

1. Socket Event Synchronization:
   - Player 1 must listen for Player 2's events and vice versa
   - Damage events must be properly routed between players
   - Point updates must target the correct opponent

2. Variable Scope:
   - Global variables (realdamage, localpoints, etc.) need player-specific scoping
   - Consider moving to instance variables to avoid conflicts

3. Import Dependencies:
   - Circular import issues need to be resolved
   - Consider dependency injection pattern for board references

4. DOM Container Management:
   - Ensure each game instance targets the correct DOM container
   - Prevent cross-contamination between player instances

This consolidation will significantly reduce code duplication while maintaining all multiplayer functionality.
